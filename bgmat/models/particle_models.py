#!/usr/bin/python
#
# Copyright 2022 DeepMind Technologies Limited
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Modifications copyright 2025 Maximilian Schebek, Freie Universit√§t Berlin
# Modified: 2025-10-03 - Adapted and extended for bgmat project. Further modifications should be documented here.


"""Particle models."""

import abc
import math
from typing import Optional, Tuple
from bgmat.models.center_of_mass import subtract_center_of_mass

import chex
import distrax
from bgmat.utils import lattice_utils
from bgmat.utils import observable_utils as obs_utils
import jax
import jax.numpy as jnp
import numpy as np
from tensorflow_probability.substrates import jax as tfp

Array = chex.Array
PRNGKey = Array


class ParticleModel(distrax.Distribution, metaclass=abc.ABCMeta):
    """A distribution over particles confined in a box.

    It assumes that the box has periodic boundary conditions (it's a torus).

    A sample from this distribution is a set of N particles in a D-dimensional
    box. Each particle is described by a vector of D position coordinates. A
    sample from this distribution has shape [N, D].
    """

    def __init__(self, num_particles: int, lower: Array, upper: Array):
        """Constructor.

        Args:
          num_particles: number of particles.
          lower: array of shape [dim], the lower ranges of the box.
          upper: array of shape [dim], the upper ranges of the box.
        """
        if num_particles < 1:
            raise ValueError(
                f"The number of particles must be at least 1, got {num_particles}."
            )
        if lower.ndim != 1:
            raise ValueError(
                f"`lower` must have one array dimension, "
                f"got `lower.ndim = {lower.ndim}`."
            )
        if upper.ndim != 1:
            raise ValueError(
                f"`upper` must have one array dimension, "
                f"got `upper.ndim = {upper.ndim}`."
            )
        (dim,) = lower.shape
        if upper.shape != (dim,):
            raise ValueError(
                f"`lower` and `upper` must have the same shape. Got "
                f"`lower.shape = {lower.shape}` and `upper.shape = {upper.shape}`."
            )
        if np.any(lower >= upper):
            raise ValueError(
                f"`lower` components must be less than `upper` components. "
                f"Got `lower == {lower}` and `upper == {upper}`."
            )
        self._num_particles = num_particles
        self._dim = dim
        self._lower = lower
        self._upper = upper
        self._width = upper - lower
        super().__init__()

    @property
    def num_particles(self) -> int:
        return self._num_particles

    @num_particles.setter
    def num_particles(self, value):
        self._num_particles = value

    @property
    def dim(self) -> int:
        return self._dim

    @property
    def lower(self) -> Array:
        return self._lower

    @property
    def upper(self) -> Array:
        return self._upper

    @property
    def width(self) -> Array:
        return self._width

    @property
    def event_shape(self) -> Tuple[int, int]:
        return (self._num_particles, self._dim)

    def wrap(self, x: Array) -> Array:
        """Wraps `x` back into the box."""
        return jnp.mod(x - self._lower, self._width) + self._lower

    def log_prob(self, particles: Array) -> Array:
        if particles.shape[-2:] != self.event_shape:
            raise ValueError(
                f"Events of shape {particles.shape[-2:]} were passed to `log_prob`,"
                f" but `{self.name}` expects events of shape {self.event_shape}."
            )
        return self._log_prob_no_checks(particles)

    def _log_prob_no_checks(self, particles: Array) -> Array:
        """Called by `log_prob`. Should be implemented in a subclass."""
        raise NotImplementedError(
            "`log_prob` is not implemented for " f"`{self.name}`."
        )


class AugmentedLattice(ParticleModel, metaclass=abc.ABCMeta):
    """A particle model based on a lattice for sampling particles with an additional auxiliary distribution.

    Samples are generated by adding random noise to the lattice followed by a
    random permutation of particles. The noise is drawn i.i.d. from a distribution
    that is defined on a suitable interval such that perturbed particles never
    escape their lattice sites.
    """

    def __init__(
        self,
        num_particles: int,
        lower: Array,
        upper: Array,
        noise_scale: float,
        noise_scale_aux: float,
        cell_aspect: Array,
        atom_positions_in_cell: Array,
        remove_com: bool,
        wrap: bool,
    ):
        """Constructor.

        Args:
          num_particles: number of particles.
          lower: array of shape [dim], the lower ranges of the box.
          upper: array of shape [dim], the upper ranges of the box.
          noise_scale: scale for the noise distribution.
          cell_aspect: vector of length `dim` with the relative length of each
            of the unit cell axes.
          atom_positions_in_cell: [N x dim] matrix of fractional coordinates of
            atoms within each unit cell (N being the number of atoms per cell).
          remove_com:
            If True, we remove the Center of Mass (CoM) of the physical distribution. The auxiliary dimensions remain unaltered. Note that if True, we do not subtract the log of the permutations because we directly operate on the CoM=0 subspace.
          spherical_noise: whether to cut off the noise spherically or
            indepedently across each axis.
        """
        super().__init__(num_particles, lower, upper)
        if noise_scale < 0.0:
            raise ValueError(f"`noise_scale` can't be negative; got {noise_scale}.")
        self._cell_aspect = cell_aspect
        self._atom_positions_in_cell = atom_positions_in_cell
        self._remove_com = remove_com
        self._lattice, self._lattice_constant, self._repeats = self._make_lattice()
        self._fractional_lattice = self._lattice / self.width

        noise_dist = distrax.Normal(
            loc=jnp.zeros((self.num_particles, self.dim)), scale=noise_scale
        )
        self._noise_dist = distrax.Independent(noise_dist, 2)

        noise_dist_aux = distrax.Normal(
            loc=jnp.zeros((self.num_particles, self.dim)), scale=noise_scale_aux
        )
        self._noise_dist_aux = distrax.Independent(noise_dist_aux, 2)

        self._wrap = wrap

    @property
    def lattice(self) -> Array:
        return self._lattice

    @property
    def fractional_lattice(self) -> Array:
        return self._fractional_lattice

    @lattice.setter
    def lattice(self, value):
        self._lattice = value

    @property
    def lattice_constant(self) -> Array:
        return self._lattice_constant

    def _make_lattice(self) -> Tuple[Array, Array, Array]:
        """Returns a lattice and its lattice constant."""
        lattice, lc, repeats = lattice_utils.make_lattice(
            self.lower,
            self.upper,
            self._cell_aspect,
            self._atom_positions_in_cell,
            self.num_particles,
        )
       
        lattice = self.wrap(lattice)
        return lattice, lc, repeats

    def _sample_n_and_log_prob(self, key: PRNGKey, n: int) -> Tuple[Array, Array]:
        keys = jax.random.split(key, 2 + n)

        # sample n times
        noise_phys, log_prob_phys = self._noise_dist.sample_and_log_prob(
            sample_shape=n, seed=keys[0]
        )

        # optionally remove center of mass
        if self._remove_com:
            noise_phys = subtract_center_of_mass(noise_phys)
            log_prob_phys = self._noise_dist.log_prob(noise_phys)

        # compute normalization constant for unnormalized log-prob
        # assuming _noise_dist is Independent-wrapped Normal
        # infer event dimensions from the samples
        event_dims = noise_phys.shape[
            -len(self._noise_dist.event_shape) :
        ]  # last `event_ndims`
        d = jnp.prod(jnp.array(event_dims))
        log_norm = -0.5 * d * jnp.log(2 * jnp.pi) - jnp.sum(
            jnp.log(self._noise_dist.distribution.scale)
        )
        # subtract normalization constant to get unnormalized log-prob
        log_prob_phys_unnorm = log_prob_phys - log_norm

        # subtract normalization constant to get unnormal
        noise_aux, log_prob_aux = self._noise_dist_aux.sample_and_log_prob(
            sample_shape=n, seed=keys[1]
        )

        if self._wrap:
            samples_phys = self.wrap(noise_phys + self._lattice)
            samples_aux = self.wrap(samples_phys + noise_aux)
        else:
            samples_phys = noise_phys
            samples_aux = samples_phys + noise_aux

        samples = jnp.concat((samples_phys, samples_aux), axis=-2)

        # Return unnormalized phys log prob so we can directly compare to MBAR using Einstein crystal
        log_prob = log_prob_phys_unnorm + log_prob_aux

        return samples, log_prob

    def _sample_n(self, key: PRNGKey, n: int) -> Array:
        samples, _ = self._sample_n_and_log_prob(key, n)
        return samples

    def _wrap_displacement(self, dx: Array) -> Array:
        """Returns the difference vector to the nearest image under PBCs."""
        return dx - self.width * jnp.round(dx / self.width)

    def _get_nearest_lattice_indices(self, x: Array) -> Array:
        """Returns indices of the nearest lattice sites."""
        deltas = self.lattice[..., :, None, :] - x[..., None, :, :]
        deltas = self._wrap_displacement(deltas)
        sq_dist = jnp.sum(deltas**2, axis=-1)
        return jnp.argmin(sq_dist, axis=-2)

    def _check_single_occupation(self, indices: Array) -> bool:
        """Returns True if each lattice index appears once otherwise False."""
        index_error = jnp.sort(indices) - jnp.arange(self.num_particles)
        return jnp.all(index_error == 0)

    def _log_prob_no_checks(self, particles: Array) -> Array:
        if not self._spherical_noise:
            raise NotImplementedError(
                "The log_prob for non-spherical noise is not " "yet implemented."
            )
        if self._wrap:
            indices = self._get_nearest_lattice_indices(particles)
            noise = self._wrap_displacement(particles - self.lattice[indices])
        else:
            noise = particles
        log_prob = self._noise_dist.log_prob(noise) - self._log_num_permutations
        return log_prob


class AugmentedDiamondCubicLattice(AugmentedLattice):
    """A particle model based on a diamond cubic lattice.

    The unit cell of a diamond cubic lattice contains eight atoms: the four atoms
    of the FCC unit cell and an additional four atoms that are located within the
    unit cell. See here for more details on the mathematical structure and an
    illustration: https://en.wikipedia.org/wiki/Diamond_cubic.

    Note that this lattice requires three spatial dimensions (`dim == 3`).
    """

    def __init__(
        self,
        num_particles: int,
        lower: Array,
        upper: Array,
        noise_scale: float,
        noise_scale_aux: float,
        remove_com: bool,
        wrap: bool = True,
    ):
        """Constructor.

        Args:
          num_particles: number of particles.
          lower: array of shape [dim], the lower ranges of the box.
          upper: array of shape [dim], the upper ranges of the box.
          noise_scale: scale for the noise distribution.
        """
        dim = lower.shape[-1]
        if dim != 3:
            raise ValueError(f"Expected the box dimensionality to be 3, got {dim}.")
        cell_aspect = np.ones(dim)
        atom_positions_in_cell = (
            np.array(
                [
                    # The first 4 atoms are the same as for FCC.
                    [0.0, 0.0, 0.0],
                    [0.0, 2.0, 2.0],
                    [2.0, 0.0, 2.0],
                    [2.0, 2.0, 0.0],
                    # The additional are located within the unit cell.
                    [3.0, 3.0, 3.0],
                    [3.0, 1.0, 1.0],
                    [1.0, 3.0, 1.0],
                    [1.0, 1.0, 3.0],
                ]
            )
            / 4
            + 0.125
        )
        super().__init__(
            num_particles,
            lower,
            upper,
            noise_scale,
            noise_scale_aux,
            cell_aspect,
            atom_positions_in_cell,
            remove_com,
            wrap,
        )


class AugmentedHexagonalIceLattice(AugmentedLattice):
    """A particle model based on a diamond cubic lattice.

    The unit cell of a diamond cubic lattice contains eight atoms: the four atoms
    of the FCC unit cell and an additional four atoms that are located within the
    unit cell. See here for more details on the mathematical structure and an
    illustration: https://en.wikipedia.org/wiki/Diamond_cubic.

    Note that this lattice requires three spatial dimensions (`dim == 3`).
    """

    def __init__(
        self,
        num_particles: int,
        lower: Array,
        upper: Array,
        noise_scale: float,
        noise_scale_aux: float,
        remove_com: bool,
        wrap: bool = True,
    ):
        """Constructor.

        Args:
        num_particles: number of particles.
        lower: array of shape [dim], the lower ranges of the box.
        upper: array of shape [dim], the upper ranges of the box.
        noise_scale: scale for the noise distribution.

        """
        dim = lower.shape[-1]
        if dim != 3:
            raise ValueError(f"Expected the box dimensionality to be 3, got {dim}.")
        # According to http://people.cs.uchicago.edu/~ridg/digbio12/primerice.pdf
        # within the non-orthogonal base cell:
        #
        # base = np.array([[1, 0, 0],
        #                  [-0.5, np.sqrt(3)/2, 0],
        #                  [0, 0, 2*np.sqrt(6)/3]])
        #
        # we need 4 atoms at absolute coordinates:
        #
        # atom_coords = np.array([[0.5, np.sqrt(3)/6, np.sqrt(6)/24],
        #                         [1.0, np.sqrt(3)/3, 15*np.sqrt(6)/24],
        #                         [0.5, np.sqrt(3)/6, 7*np.sqrt(6)/24],
        #                         [1.0, np.sqrt(3)/3, 8*np.sqrt(6)/2]])
        #
        # We make an orthogonal cell from integer multiples of the
        # non-orthogonal base:
        #
        # ortho_base = np.array([[1, 0, 0],
        #                        [1, 2, 0],
        #                        [0, 0, 1]]) @ base
        #
        # This orthogonal cell has twice the volume of the non-orthogonal base
        # and the relative atom coordinates within it can be easily found by
        # replicating the non-orthogonal cell and retaining only atoms within
        # the orthogonal one. This results in the 8 atom positions below.
        cell_aspect = np.array([1.0, np.sqrt(3), np.sqrt(8 / 3)])
        a = 6 * 0.0625
        atom_positions_in_cell = (
            np.array(
                [
                    [3.0, 5.0, 3 + a],
                    [0.0, 4.0, 0 + a],
                    [0.0, 2.0, 3 + a],
                    [3.0, 1.0, 0 + a],
                    [0.0, 2.0, 6 - a],
                    [3.0, 1.0, 3 - a],
                    [3.0, 5.0, 6 - a],
                    [0.0, 4.0, 3 - a],
                ]
            )
            / 6.0
        )
        super().__init__(
            num_particles,
            lower,
            upper,
            noise_scale,
            noise_scale_aux,
            cell_aspect,
            atom_positions_in_cell,
            remove_com,
            wrap,
        )


class AugmentedBodyCenteredCubicLattice(AugmentedLattice):
    """A particle model based on a diamond cubic lattice.

    The unit cell of a diamond cubic lattice contains eight atoms: the four atoms
    of the FCC unit cell and an additional four atoms that are located within the
    unit cell. See here for more details on the mathematical structure and an
    illustration: https://en.wikipedia.org/wiki/Diamond_cubic.

    Note that this lattice requires three spatial dimensions (`dim == 3`).
    """

    def __init__(
        self,
        num_particles: int,
        lower: Array,
        upper: Array,
        noise_scale: float,
        noise_scale_aux: float,
        remove_com: bool,
        wrap: bool = True,
    ):
        """Constructor.

        Args:
          num_particles: number of particles.
          lower: array of shape [dim], the lower ranges of the box.
          upper: array of shape [dim], the upper ranges of the box.
          noise_scale: scale for the noise distribution.
        """
        dim = lower.shape[-1]
        if dim != 3:
            raise ValueError(f"Expected the box dimensionality to be 3, got {dim}.")
        cell_aspect = np.ones(dim)
        atom_positions_in_cell = (
            np.array(
                [
                    # The first 4 atoms are the same as for FCC.
                    [0.0, 0.0, 0.0],
                    [1.0, 1.0, 1.0],
                ]
            )
            / 2
        )
        super().__init__(
            num_particles,
            lower,
            upper,
            noise_scale,
            noise_scale_aux,
            cell_aspect,
            atom_positions_in_cell,
            remove_com,
            wrap,
        )


class AugmentedBetaTinLattice(AugmentedLattice):
    """A particle model based on a diamond cubic lattice.

    The unit cell of a diamond cubic lattice contains eight atoms: the four atoms
    of the FCC unit cell and an additional four atoms that are located within the
    unit cell. See here for more details on the mathematical structure and an
    illustration: https://en.wikipedia.org/wiki/Diamond_cubic.

    Note that this lattice requires three spatial dimensions (`dim == 3`).
    """

    def __init__(
        self,
        num_particles: int,
        lower: Array,
        cell_aspect: Array,
        upper: Array,
        noise_scale: float,
        noise_scale_aux: float,
        remove_com: bool,
        delta_betatin: float = 0.0,
        wrap: bool = True,
    ):
        """Constructor.

        Args:
          num_particles: number of particles.
          lower: array of shape [dim], the lower ranges of the box.
          upper: array of shape [dim], the upper ranges of the box.
          noise_scale: scale for the noise distribution.
        """
        dim = lower.shape[-1]
        if dim != 3:
            raise ValueError(f"Expected the box dimensionality to be 3, got {dim}.")
        atom_positions_in_cell = np.array(
            [[0.0, 0.0, 0.0], [0.0, 0.5, 0.25], [0.5, 0.5, 0.5], [0.5, 0.0, 0.75]],
        ) + delta_betatin * np.array(
            [
                [0.0, 0.0, 0.0],
                [1.0, 0.0, 0.0],
                [1.0, 1.0, 0.0],
                [0.0, 1.0, 0.0],
            ]
        )
        super().__init__(
            num_particles,
            lower,
            upper,
            noise_scale,
            noise_scale_aux,
            cell_aspect,
            atom_positions_in_cell,
            remove_com,
            wrap,
        )


class AugmentedFaceCentredCubicLattice(AugmentedLattice):
    """A particle model based on a diamond cubic lattice.

    The unit cell of a diamond cubic lattice contains eight atoms: the four atoms
    of the FCC unit cell and an additional four atoms that are located within the
    unit cell. See here for more details on the mathematical structure and an
    illustration: https://en.wikipedia.org/wiki/Diamond_cubic.

    Note that this lattice requires three spatial dimensions (`dim == 3`).
    """

    def __init__(
        self,
        num_particles: int,
        lower: Array,
        upper: Array,
        noise_scale: float,
        noise_scale_aux: float,
        remove_com: bool,
        is_orthorhombic: bool = False,
        wrap: bool = True,
    ):
        """Constructor.

        Args:
          num_particles: number of particles.
          lower: array of shape [dim], the lower ranges of the box.
          upper: array of shape [dim], the upper ranges of the box.
          noise_scale: scale for the noise distribution.
        """
        dim = lower.shape[-1]
        if dim != 3:
            raise ValueError(f"Expected the box dimensionality to be 3, got {dim}.")
        if is_orthorhombic:
            cell_aspect = np.array([1.0, np.sqrt(3), np.sqrt(6)])
            atom_positions_in_cell = np.array(
                [
                    [0.0, 0.0, 0.0],
                    [0.50, 0.50, 0.00],
                    [0.0, 4.0 / 6.0, 1.0 / 3],
                    [0.5, 1.0 / 6.0, 1.0 / 3],
                    [0.0, 2.0 / 6.0, 2.0 / 3],
                    [0.5, 5.0 / 6.0, 2.0 / 3],
                ]
            )
        else:
            cell_aspect = np.ones(dim)
            atom_positions_in_cell = (
                np.array(
                    [[0.0, 0.0, 0.0], [1.0, 1.0, 0.0], [1.0, 0.0, 1.0], [0.0, 1.0, 1.0]]
                )
                / 2
            )
        super().__init__(
            num_particles,
            lower,
            upper,
            noise_scale,
            noise_scale_aux,
            cell_aspect,
            atom_positions_in_cell,
            remove_com,
            wrap,
        )


class AugmentedHexagonalClosePackedLattice(AugmentedLattice):
    """A particle model based on a diamond cubic lattice.

    The unit cell of a diamond cubic lattice contains eight atoms: the four atoms
    of the FCC unit cell and an additional four atoms that are located within the
    unit cell. See here for more details on the mathematical structure and an
    illustration: https://en.wikipedia.org/wiki/Diamond_cubic.

    Note that this lattice requires three spatial dimensions (`dim == 3`).
    """

    def __init__(
        self,
        num_particles: int,
        lower: Array,
        upper: Array,
        noise_scale: float,
        noise_scale_aux: float,
        remove_com: bool,
        wrap: bool = True,
        is_orthorhombic: bool = None,
    ):
        """Constructor.

        Args:
          num_particles: number of particles.
          lower: array of shape [dim], the lower ranges of the box.
          upper: array of shape [dim], the upper ranges of the box.
          noise_scale: scale for the noise distribution.
        """
        dim = lower.shape[-1]
        if dim != 3:
            raise ValueError(f"Expected the box dimensionality to be 3, got {dim}.")
        cell_aspect = np.array([1.0, np.sqrt(3), np.sqrt(8.0 / 3.0)])
        atom_positions_in_cell = np.array(
            [
                [0.0, 0.0, 0.0],
                [0.50, 0.50, 0.00],
                [0.0, 4.0 / 6.0, 1.0 / 2],
                [0.5, 1.0 / 6.0, 1.0 / 2],
            ]
        )
        super().__init__(
            num_particles,
            lower,
            upper,
            noise_scale,
            noise_scale_aux,
            cell_aspect,
            atom_positions_in_cell,
            remove_com,
            wrap,
        )

