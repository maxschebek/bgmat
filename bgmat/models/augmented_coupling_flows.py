#!/usr/bin/python
#
# Copyright 2022 DeepMind Technologies Limited
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Modifications copyright 2025 Maximilian Schebek, Freie UniversitÃ¤t Berlin
# Modified: 2025-10-03 - Adapted and extended for bgmat project. Further modifications should be documented here.


"""Coupling flows for particle models."""

import functools
from typing import Any, Callable, Mapping, Sequence, Union

import chex
import distrax
import haiku as hk
import jax
import jax.numpy as jnp
from tensorflow_probability.substrates import jax as tfp
from bgmat.models.center_of_mass import ShiftCenterOfMass
from bgmat.models.conditional_split_coupling import (
    ChainConditional,
    ConditionalBlock,
    ConditionalSplitCoupling,
)

Array = chex.Array
PRNGKey = Array


def _reshape_last(x: Array, ndims: int, new_shape: Sequence[int]) -> Array:
    """Reshapes the last `ndims` dimensions of `x` to shape `new_shape`."""
    if ndims <= 0:
        raise ValueError(
            f"Number of dimensions to reshape must be positive, got {ndims}."
        )
    return jnp.reshape(x, x.shape[:-ndims] + tuple(new_shape))


def return_x(x, *args, **kwargs):
    return x


def make_equivariant_conditioner(
    shape_transformed: Sequence[int],
    num_bijector_params: int,
    conditioner_constructor: Callable[..., Any],
    conditioner_kwargs: Mapping[str, Any],
    w_init_final: hk.initializers.Initializer = jnp.zeros,
) -> Callable[[Array], Array]:
    """
    Constructs a permutation-equivariant conditioner for use in coupling flows.

    Args:
        shape_transformed: Shape of the transformed part of the input (e.g., [N, d]).
        num_bijector_params: Number of parameters required by the bijector per output dimension.
        conditioner_constructor: Callable that returns a Haiku module for feature extraction.
        conditioner_kwargs: Dictionary of keyword arguments for the conditioner constructor.
        w_init_final: Initializer for the final linear layer (default: zeros).

    Returns:
        A callable Haiku module that maps input arrays to bijector parameters with shape (..., output_size, num_bijector_params), where output_size = shape_transformed[-1].
    """
    output_size = shape_transformed[-1]
    conditioner = conditioner_constructor(**conditioner_kwargs)

    return hk.Sequential(
        [
            conditioner,
            hk.Linear(output_size * num_bijector_params, w_init=w_init_final),
            functools.partial(
                _reshape_last, ndims=1, new_shape=(output_size, num_bijector_params)
            ),
        ]
    )


def make_split_coupling_flow(
    event_shape: Sequence[int],
    lower_spline: float,
    upper_spline: float,
    boundary_slopes: str,
    num_layers: int,
    num_bins: int,
    conditioner: Mapping[str, Any],
    split_axis: int,
    use_com_shift: bool,
    num_blocks_per_layer: int,
    prng: Union[int, PRNGKey],
) -> distrax.Bijector:
    """Create a flow that consists of a sequence of split coupling layers.

    All coupling layers use rational-quadratic splines. Each layer of the flow
    is composed of two split coupling bijectors, where each coupling bijector
    transforms a different part of the input.


    Args:
      event_shape: the shape of the event generated by the flow. Does not
        include the batch dimensions.
      lower: lower range of the flow.
      upper: upper range of the flow.
      num_layers: the number of layers to use. Each layer consists of two split
        coupling bijectors, where each coupling bijector transforms a different
        part of the input.
      num_bins: number of bins to use in the rational-quadratic splines.
      conditioner: a Mapping containing 'constructor' and 'kwargs' keys that
        configures the conditioner used in the coupling layers.
      split_axis: a negative int that defines which axis to split along.
      use_com_shift: if True,ensure that the transformed variable has CoM /= 0, while the fixed variable has CoM=0.
      prng: either a PRNG key, or an integer seed to convert to a PRNG key. The
        PRNG key will be used to construct the permutations, when these are
        random.

    Returns:
      The flow, a Distrax bijector.
    """
    if isinstance(prng, int):
        prng = jax.random.PRNGKey(prng)

    if split_axis >= 0:
        raise ValueError(f"Expected split axis to be negative, got {split_axis}.")

    def bijector_fn(params: Array):
        return distrax.RationalQuadraticSpline(
            params,
            range_min=lower_spline,
            range_max=upper_spline,
            boundary_slopes=boundary_slopes,
            min_bin_size=(upper_spline - lower_spline) * 1e-4,
        )

    split_size = event_shape[split_axis]
    split_index = split_size // 2
    swap_dimensions = num_blocks_per_layer * [True] + num_blocks_per_layer * [False]
    previous_swap = None

    layers = []
    for _ in range(num_layers):
        sublayers = []

        # Coupling layers.
        for swap in swap_dimensions:
            shape_transformed = list(event_shape)
            shape_transformed[split_axis] = (
                split_index if swap else split_size - split_index
            )
            if use_com_shift:
                if swap != previous_swap:
                    com_swap_layer = ShiftCenterOfMass(
                        swap=swap, event_n_dims_in=len(event_shape)
                    )
                    sublayers.append(com_swap_layer)
                previous_swap = swap

            coupling_layer = ConditionalSplitCoupling(
                swap=swap,
                split_index=split_index,
                split_axis=split_axis,
                event_ndims=len(event_shape),
                bijector=bijector_fn,
                conditioner=conditioner["constructor"](
                    shape_transformed=shape_transformed,
                    num_bijector_params=3 * num_bins + 1,
                    **conditioner["kwargs"],
                ),
            )
            sublayers.append(coupling_layer)
        layers.append(ChainConditional(sublayers))

    return ChainConditional(layers)

